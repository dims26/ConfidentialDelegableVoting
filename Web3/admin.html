<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
  <meta name="description" content="Open Vote Network on Ethereum">
  <meta name="author" content="Paddy">
  <title>Admin Page</title>

  <!-- Bootstrap core CSS -->
  <link href="css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="starter-template.css" rel="stylesheet">

  <link href="css/jquery.datetimepicker.css" rel="stylesheet">

  <link href="css/admin.css" rel="stylesheet">

</head>

<body>

  <div class="container">
    <ul id="progressbar">
      <li id="pb_unlock" class="active">Unlock Address</li>
      <li id="pb_setup">Set up</li>
      <li id="pb_register">Register</li>
      <li id="pb_commit">Commit</li>
      <li id="pb_cast">Cast</li>
      <li id="pb_tally">Tally</li>
    </ul>
    <div class="jumbotron">
      <h2 id="title">Login to Ethereum</h2>
      <p id="section_desc"></p>
      <p id="question"></p>
      <div hidden id="login">
        <div id='dropdown'></div>
      </div>
      <div hidden id="eligible">
        <p id="eligible_area">
          <textarea id="addresses" name="list" cols="40" rows="5"></textarea>
          <br>
          <button onclick="setEligible()" class="btn btn-secondary">Update eligibility list</button>
        </p>
        <p><button onclick="finishEligible()" class="btn btn-primary">Next</button></p>
      </div>

      <div hidden id="listoftimers">
        <div id="registrationSetTimes">

          <p>A timetable is necessary to ensure the election progresses in a timely manner. All active voters are
            guaranteed that their deposit is returned if a deadline is missed. </p>
          <hr>

          <p>What time should the election begin? </p>
          <p id="datepairExample">
            Voters should register by <input id="datetimepickerfinishby" type="text">
          </p>
          <hr>

          <p>Set a deadline for each phase in the election:
          <p id="endSignup">
            Begin Election: <input id="datetimepickerendsignup" type="text">
          </p>
          <p id="endCommitment">
            Commitment: <input id="datetimepickerendcommitment" type="text">
          </p>
          <p id="endVote">
            Voting: <input id="datetimepickerendvote" type="text">
          </p>
          <p id="endRefund">
            Refund: <input id="datetimepickerendrefund" type="text">
          </p>

        </div>
        <p><button onclick="finishSetTimes()" class="btn btn-primary">Next</button></p>
      </div>

      <div hidden id="registrationSetQuestion">
        <p>Question: <input type='text' id='questioninput' value='Dummy Question?' /> </p>
        <p id="deposit">
          Deposit required: <input type="number" id='depositinput' value='1' />
        </p>
        <p><input type="checkbox" id="commitmenttick" checked> Enable the 'Commitment' Phase?</p>
        <p id="beginRegistrationbutton"><button onclick="beginRegistration()" class="btn btn-primary">Begin Registration
            Phase</button></p>
      </div>

      <div hidden id="finishRegistration">
        <p id="currentRegistration"></p>
        <p id="finishby"></p>
        <p id="totalregistered"></p>
        <button class="btn btn-primary" onclick="finishRegistration()">Finish Registration Phase</button>
      </div>

      <div hidden id="commit">
        <p id="totalcommit"></p>
        <hr>
        <p id="committimer"></p>
      </div>
      <div hidden id="votephase">
        <p id="totalvoters"></p>
        <p id="tallybutton"><button onclick="tally()" class="btn btn-primary">Get Tally</button></p>
        <hr>
        <p id="votetimer"></p>
      </div>
      <div hidden id="tallydiv">
        <p><span id="depositrefunded"></span>
          <hr>
        <p id="newvote"></p>
        <div hidden id="refund-valid">
          <p>Claim your deposit of <span id="refund"></span> ether before <span id="refundclock"></span></p>
          <p id="claimrefundbutton"><button onclick="claimrefund()" class="btn btn-success">Claim Refund</button></p>
          <p hidden id="waitingforrefund">Waiting for Ethereum to confirm your refund</p>
        </div>

        <button onclick="resetElection()" class="btn btn-success">Start a new vote</button>
      </div>
    </div>
  </div>

  <!-- <hr> -->
  <div>
    <br>
    <div hidden id="cancelelec"><button id="cancelelectionbutton" onclick="cancelElection()"
        class="btn btn-danger">Cancel Election</button></div>
    <div hidden id="unspentdeposits"><button onclick="claimUnspentDeposits()" class="btn btn-danger">Send deposits to
        Charity</button></div>
  </div>
  <div hidden id="txlist">
    <p>Transaction List:</p>
  </div>
  <div hidden id="infodiv">
    <p>Events from Ethereum:</p>
  </div>
  </div><!-- /.container -->

  <!-- Bootstrap core JavaScript
    ================================================== -->
  <!-- Placed at the end of the document so the pages load faster -->
  <script src="js/jquery.min.js"></script>
  <script src="js/bootstrap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
  <script src="bignumber.min.js"></script>
  <script src="js/jquery.datetimepicker.js"></script>

  <script>

    // Relevant code that talks to Ethereum
    var web3;
    var password = "";
    var adminAddressChosen = false;
    var addr = 0;
    var state = 0;
    var accountindex = 0;

    if (typeof web3 !== 'undefined') {
      web3 = new Web3(web3.currentProvider);
    } else {
      // set the provider you want from Web3.providers
      web3 = new Web3(new Web3.providers.HttpProvider("http://localhost:7545"));
    }

    // Anonymous Voting Contract
    var abi = [{ "inputs": [{ "internalType": "uint256", "name": "_gap", "type": "uint256" }, { "internalType": "address", "name": "_charity", "type": "address" }], "stateMutability": "nonpayable", "type": "constructor" }, { "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "name": "addresses", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "addressid", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "string", "name": "_question", "type": "string" }, { "internalType": "bool", "name": "enableCommitmentPhase", "type": "bool" }, { "internalType": "uint256", "name": "_votersFinishSignupPhase", "type": "uint256" }, { "internalType": "uint256", "name": "_endSignupPhase", "type": "uint256" }, { "internalType": "uint256", "name": "_endCommitmentPhase", "type": "uint256" }, { "internalType": "uint256", "name": "_endVotingPhase", "type": "uint256" }, { "internalType": "uint256", "name": "_endRefundPhase", "type": "uint256" }, { "internalType": "uint256", "name": "_depositrequired", "type": "uint256" }], "name": "beginSignUp", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "payable", "type": "function" }, { "inputs": [], "name": "charity", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "commitment", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "commitmentphase", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "computeTally", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "deadlinePassed", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "depositrequired", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "eligible", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "endCommitmentPhase", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "endRefundPhase", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "endSignupPhase", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "endVotingPhase", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "name": "finaltally", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "finishRegistrationPhase", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "gap", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "getVoter", "outputs": [{ "internalType": "uint256[2]", "name": "_registeredkey", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "_reconstructedkey", "type": "uint256[2]" }, { "internalType": "bytes32", "name": "_commitment", "type": "bytes32" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "lostdeposit", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "owner", "outputs": [{ "internalType": "address", "name": "", "type": "address" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "question", "outputs": [{ "internalType": "string", "name": "", "type": "string" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "refunds", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256[2]", "name": "xG", "type": "uint256[2]" }, { "internalType": "uint256[3]", "name": "vG", "type": "uint256[3]" }, { "internalType": "uint256", "name": "r", "type": "uint256" }], "name": "register", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "payable", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "registered", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "sendToCharity", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "address[]", "name": "addr", "type": "address[]" }], "name": "setEligible", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "state", "outputs": [{ "internalType": "enum AnonymousVoting.State", "name": "", "type": "uint8" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "bytes32", "name": "h", "type": "bytes32" }], "name": "submitCommitment", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256[4]", "name": "params", "type": "uint256[4]" }, { "internalType": "uint256[2]", "name": "y", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "a1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "b1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "a2", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "b2", "type": "uint256[2]" }], "name": "submitVote", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [], "name": "totalcommitted", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totaleligible", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totalrefunded", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totalregistered", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totaltorefund", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "totalvoted", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "newOwner", "type": "address" }], "name": "transferOwnership", "outputs": [], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256[4]", "name": "params", "type": "uint256[4]" }, { "internalType": "uint256[2]", "name": "y", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "a1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "b1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "a2", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "b2", "type": "uint256[2]" }], "name": "verify1outof2ZKP", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256[2]", "name": "xG", "type": "uint256[2]" }, { "internalType": "uint256", "name": "r", "type": "uint256" }, { "internalType": "uint256[3]", "name": "vG", "type": "uint256[3]" }], "name": "verifyZKP", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "address", "name": "", "type": "address" }], "name": "votecast", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "name": "voters", "outputs": [{ "internalType": "address", "name": "addr", "type": "address" }, { "internalType": "bytes32", "name": "commitment", "type": "bytes32" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "votersFinishSignupPhase", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [], "name": "withdrawRefund", "outputs": [], "stateMutability": "nonpayable", "type": "function" }];
    var anonymousvoting = new web3.eth.Contract(abi, "0xC9EBa7F4DaAeC4662c9d6b8ca7b6DE20e7a85307");
    var anonymousvotingAddr = anonymousvoting._address;

    // Local Crypto Contract
    var abi_crypto = [{ "inputs": [], "stateMutability": "nonpayable", "type": "constructor" }, { "anonymous": false, "inputs": [{ "indexed": false, "internalType": "uint256", "name": "x1", "type": "uint256" }, { "indexed": false, "internalType": "uint256", "name": "x2", "type": "uint256" }], "name": "Debug", "type": "event" }, { "inputs": [{ "internalType": "uint256[4]", "name": "params", "type": "uint256[4]" }, { "internalType": "uint256[2]", "name": "xG", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "yG", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "y", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "a1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "b1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "a2", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "b2", "type": "uint256[2]" }], "name": "commitToVote", "outputs": [{ "internalType": "bytes32", "name": "", "type": "bytes32" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256[2]", "name": "c1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "c2", "type": "uint256[2]" }, { "internalType": "uint256", "name": "h", "type": "uint256" }, { "internalType": "uint256[2]", "name": "t", "type": "uint256[2]" }], "name": "computeFirstHalfEquality", "outputs": [{ "internalType": "uint256[2]", "name": "left", "type": "uint256[2]" }], "stateMutability": "pure", "type": "function" }, { "inputs": [{ "internalType": "uint256[2]", "name": "c1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "c2", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "t2", "type": "uint256[2]" }, { "internalType": "uint256", "name": "h", "type": "uint256" }], "name": "computeSecondHalfInequality", "outputs": [{ "internalType": "uint256[3]", "name": "right", "type": "uint256[3]" }], "stateMutability": "pure", "type": "function" }, { "inputs": [{ "internalType": "uint256[2]", "name": "xG", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "yG", "type": "uint256[2]" }, { "internalType": "uint256", "name": "w", "type": "uint256" }, { "internalType": "uint256", "name": "r2", "type": "uint256" }, { "internalType": "uint256", "name": "d2", "type": "uint256" }, { "internalType": "uint256", "name": "x", "type": "uint256" }], "name": "create1outof2ZKPNoVote", "outputs": [{ "internalType": "uint256[10]", "name": "res", "type": "uint256[10]" }, { "internalType": "uint256[4]", "name": "res2", "type": "uint256[4]" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256[2]", "name": "xG", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "yG", "type": "uint256[2]" }, { "internalType": "uint256", "name": "w", "type": "uint256" }, { "internalType": "uint256", "name": "r1", "type": "uint256" }, { "internalType": "uint256", "name": "d1", "type": "uint256" }, { "internalType": "uint256", "name": "x", "type": "uint256" }], "name": "create1outof2ZKPYesVote", "outputs": [{ "internalType": "uint256[10]", "name": "res", "type": "uint256[10]" }, { "internalType": "uint256[4]", "name": "res2", "type": "uint256[4]" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "r1", "type": "uint256" }, { "internalType": "uint256", "name": "r2", "type": "uint256" }, { "internalType": "uint256", "name": "r3", "type": "uint256" }, { "internalType": "uint256[2]", "name": "c1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "c2", "type": "uint256[2]" }], "name": "createEqualityProof", "outputs": [{ "internalType": "uint256[2]", "name": "t", "type": "uint256[2]" }, { "internalType": "uint256", "name": "n", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "b1", "type": "uint256" }, { "internalType": "uint256", "name": "b2", "type": "uint256" }, { "internalType": "uint256", "name": "r1", "type": "uint256" }, { "internalType": "uint256", "name": "r2", "type": "uint256" }, { "internalType": "uint256", "name": "r3", "type": "uint256" }, { "internalType": "uint256", "name": "r4", "type": "uint256" }, { "internalType": "uint256[2]", "name": "c1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "c2", "type": "uint256[2]" }], "name": "createInequalityProof", "outputs": [{ "internalType": "uint256[2]", "name": "t1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "t2", "type": "uint256[2]" }, { "internalType": "uint256", "name": "n1", "type": "uint256" }, { "internalType": "uint256", "name": "n2", "type": "uint256" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "x", "type": "uint256" }, { "internalType": "uint256", "name": "v", "type": "uint256" }, { "internalType": "uint256[2]", "name": "xG", "type": "uint256[2]" }], "name": "createZKP", "outputs": [{ "internalType": "uint256[4]", "name": "res", "type": "uint256[4]" }], "stateMutability": "nonpayable", "type": "function" }, { "inputs": [{ "internalType": "uint256[2]", "name": "c", "type": "uint256[2]" }, { "internalType": "uint256", "name": "r", "type": "uint256" }, { "internalType": "uint256", "name": "b", "type": "uint256" }], "name": "openCommitment", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "a", "type": "uint256" }, { "internalType": "uint256", "name": "b", "type": "uint256" }], "name": "submod", "outputs": [{ "internalType": "uint256", "name": "", "type": "uint256" }], "stateMutability": "pure", "type": "function" }, { "inputs": [{ "internalType": "uint256[4]", "name": "params", "type": "uint256[4]" }, { "internalType": "uint256[2]", "name": "xG", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "yG", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "y", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "a1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "b1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "a2", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "b2", "type": "uint256[2]" }], "name": "verify1outof2ZKP", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256", "name": "n", "type": "uint256" }, { "internalType": "uint256[2]", "name": "c1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "c2", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "t", "type": "uint256[2]" }], "name": "verifyEqualityProof", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256[2]", "name": "c1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "c2", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "t1", "type": "uint256[2]" }, { "internalType": "uint256[2]", "name": "t2", "type": "uint256[2]" }, { "internalType": "uint256", "name": "n1", "type": "uint256" }, { "internalType": "uint256", "name": "n2", "type": "uint256" }], "name": "verifyInequalityProof", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }, { "inputs": [{ "internalType": "uint256[2]", "name": "xG", "type": "uint256[2]" }, { "internalType": "uint256", "name": "r", "type": "uint256" }, { "internalType": "uint256[3]", "name": "vG", "type": "uint256[3]" }], "name": "verifyZKP", "outputs": [{ "internalType": "bool", "name": "", "type": "bool" }], "stateMutability": "view", "type": "function" }];
    var crypto_contract = new web3.eth.Contract(abi_crypto, "0x82d75f060159de29f17b233363cD4E7076db6AE1");
    let accountList = [];


    function waitForAccounts(promise) {
      let waiting = true;
      while (waiting) {
        console.log("Waiting on accounts");
        setTimeout(function () { alert("Exiting one timeout loop") }, 1000);
        promise.then(function (acc) {
          accountList = acc;
          waiting = false;
          console.log("accounts received");
        });
      }
    }

    // Controls which times and dates are displayed by default
    // We need to ensure there is a 'minimum' gap between default times too.
    // TODO: When the 'gap' drop down box is used... update all times accordingly.
    async function setInitialTimes() {

      var endreg = new Date();
      var endsignuptime = new Date();
      var gap = await anonymousvoting.methods.gap().call();

      endreg.setTime(endreg.getTime() + (gap * 1000));
      // Initial time is set here.
      jQuery('#datetimepickerfinishby').datetimepicker(
        {
          minDate: '0', // Sets minimum date as today
          value: endreg
        });

      endsignuptime.setTime(endreg.getTime() + (gap * 1000));
      jQuery('#datetimepickerendsignup').datetimepicker(
        {
          minDate: '0', // Sets minimum date as today
          value: endsignuptime
        });

      var endcommittime = new Date();
      endcommittime.setTime(endsignuptime.getTime() + (gap * 1000));
      jQuery('#datetimepickerendcommitment').datetimepicker(
        {
          minDate: '0', // Sets minimum date as today
          value: endcommittime
        });

      var endvotetime = new Date();
      endvotetime.setTime(endcommittime.getTime() + (gap * 1000));
      jQuery('#datetimepickerendvote').datetimepicker(
        {
          minDate: '0', // Sets minimum date as today
          value: endvotetime
        });

      var endrefund = new Date();
      endrefund.setTime(endvotetime.getTime() + (gap * 1000));
      jQuery('#datetimepickerendrefund').datetimepicker(
        {
          minDate: '0', // Sets minimum date as today
          value: endrefund
        });


      $.datetimepicker.setLocale('en');

    }

    async function claimUnspentDeposits() {
      await web3.eth.personal.unlockAccount(addr, password);

      await anonymousvoting.methods.sendToCharity.send({ from: accountList[accountindex], gas: 4200000 });
      let lostDeposit = await anonymousvoting.methods.lostdeposit();
      alert("The charity will receive " + web3.fromWei(lostDeposit) + " ether shortly");

      return false;
    }

    async function cancelElection() {
      await web3.eth.personal.unlockAccount(addr, password);
      var res = anonymousvoting.methods.deadlinePassed.call({ from: accountList[accountindex], gas: 4200000 });

      if (res) {
        anonymousvoting.methods.deadlinePassed.sendTransaction({ from: accountList[accountindex], gas: 4200000 });
        document.getElementById("cancelelectionbutton").setAttribute("disabled", true);
        alert("Please wait a few minutes for the election to be cancelled.");
      }

      return false;
    }
    function resetElection() {

      var currentTime = new Date();
      var endRefundTime = anonymousvoting.methods.endRefundPhase() * 1000;

      await web3.eth.personal.unlockAccount(addr, password);
      var res = anonymousvoting.methods.deadlinePassed.call({ from: accountList[accountindex], gas: 4200000 });

      if (res) {
        anonymousvoting.methods.deadlinePassed.sendTransaction({ from: accountList[accountindex], gas: 4200000 });
        document.getElementById('tallydiv').innerHTML = "Please refresh your web browser in a few minutes";
      } else {

        if (currentTime.getTime() < endRefundTime) {
          alert("A new vote cannot be started until after " + clockformat(new Date(endRefundTime)));
        } else {
          alert("Could not restart election" + anonymousvoting.methods.totaltorefund() + " AND " + anonymousvoting.methods.totalrefunded() + " ");
        }
      }

      return false;
    }


    // Check that the user is eligible to vote
    async function setEligible() {
      var tempaddr;

      if (adminAddressChosen) {

        var lastchar = document.getElementById('addresses').value.trim().slice(-1);
        var toSplit;

        // Make sure the user has not ended the list with ','
        if (lastchar == ',') {
          var len = document.getElementById('addresses').value.length;
          toSplit = document.getElementById('addresses').value.substring(0, len - 1);
        } else {
          toSplit = document.getElementById('addresses').value;
        }

        var split = toSplit.split(",");

        // TODO: Sanity check the list ... verify they are all valid Ethereum addresses
        var addresses = new Array();

        // Check with Ethereum how many addresses have ALREADY been accepted.
        // It will only hold UP to 40. No point sending 40 if Ethereum already has 25. (We should send 15 in that case).
        // todo update eligible address limit
        let totalEligible = await anonymousvoting.methods.totaleligible().call();
        console.log(totalEligible);
        var uptolimit;

        if (split.length > (40 - totalEligible)) {
          if (!confirm("We can only use the first 40 addresses... Is this ok?")) {
            return;
          }
          uptolimit = (40 - totalEligible);
        } else {
          uptolimit = split.length;
        }

        // No point re-submiting an address if it is already eligible
        for (var i = 0; i < uptolimit; i++) {
          if (!(await anonymousvoting.methods.eligible(split[i]).call())) {
            addresses.push(split[i]);
          }
        }

        // Do we have any addresses that are not yet eligible?
        if (addresses.length > 0) {
          await await web3.eth.personal.unlockAccount(addr, password);
          var res = await anonymousvoting.methods.setEligible(addresses).send({ from: accountList[accountindex], gas: 4200000 })
          console.log(res);

          txlist("Set Eligible: " + res);

          alert("Sent " + addresses.length + " addresses to Ethereum whitelist");
        } else {
          alert("All addresses are already eligible!");
        }

      } else {
        alert("You need to select the admin address first!");
      }
    }

    // Allow people to start submiting their voting key.
    async function beginRegistration() {

      if (!adminAddressChosen) {
        alert("Please unlock your Ethereum address.");
        return;
      }

      if (state != 0) {
        alert("Please wait until SETUP Phase");
        return;
      }

      // Sanity check all the timer values given to us
      var finishby_val = $('#datetimepickerfinishby').datetimepicker('getValue');
      if (finishby_val == null) {
        alert("Please select the finish time for the Registration phase");
        return;
      }

      var endsignup_val = $('#datetimepickerendsignup').datetimepicker('getValue');
      if (endsignup_val == null) {
        alert("Please select which time the Registration phase MUST end before refunds are issued");
        return;
      }

      // Make sure the option is enabled (tick box is checked)
      var enableCommitment = $('#commitmenttick').is(":checked");
      var endcommitment_val = 0;

      // Only grab commitment value if that phase is enabled...
      if (enableCommitment) {
        endcommitment_val = $('#datetimepickerendcommitment').datetimepicker('getValue');

        if (endcommitment_val == null) {
          alert("Please select which time the Commitment phase MUST end before refunds are issued");
          return;
        }
      }

      var endvote_val = $('#datetimepickerendvote').datetimepicker('getValue');
      if (endvote_val == null) {
        alert("Please select which time the Computation phase MUST end before refunds are issued");
        return;
      }

      var endrefund_val = $('#datetimepickerendrefund').datetimepicker('getValue');
      if (endrefund_val == null) {
        alert("Please select the voter's refund deadline.");
        return;
      }

      var deposit_in_ether = $('#depositinput').val()

      // Make sure deposit is not too high!
      if (deposit_in_ether > 10) {
        if (!confirm("Deposit is set to " + deposit_in_ether + " ether which is high. Are you sure this is correct?")) {
          return;
        }
      }

      var deposit_in_wei = web3.toWei(deposit_in_ether, "ether"); // We assume it is in Ether

      var finishby = Math.floor(finishby_val.getTime() / 1000); // Ethereum works in seconds, not milliseconds.
      var endsignup = Math.floor(endsignup_val.getTime() / 1000); // Ethereum works in seconds, not milliseconds.
      var endcommitment = 0;
      // Again we only store endcommitment if the phase is enabled
      if (enableCommitment) {
        endcommitment = Math.floor(endcommitment_val.getTime() / 1000); // Ethereum works in seconds, not milliseconds.
      }
      var endvote = Math.floor(endvote_val.getTime() / 1000); // Ethereum works in seconds, not milliseconds.
      var endrefund = Math.floor(endrefund_val.getTime() / 1000); // Ethereum works in seconds, not milliseconds.
      var question = document.getElementById('questioninput').value;

      await web3.eth.personal.unlockAccount(addr, password);

      if (await anonymousvoting.methods.beginSignUp(question, enableCommitment, finishby, endsignup, endcommitment, endvote, endrefund, deposit_in_wei)
        .call({ from: accountList[accountindex], value: deposit_in_wei })) {
        var res = await anonymousvoting.methods.beginSignUp(question, enableCommitment, finishby, endsignup, endcommitment, endvote, endrefund, deposit_in_wei).sendTransaction({ from: accountList[accountindex], gas: 4200000, value: deposit_in_wei });
        destroyPickers();
        document.getElementById("beginRegistrationbutton").innerHTML = "Waiting for Ethereum to confirm that Registration has started";
        txlist("Begin Registration Phase: " + res);
      } else {
        // TODO: Better error message, and perhaps JS to enforce minimum gap etc.
        alert("Ethereum will not accept those dates and times.");
      }
    }

    function destroyPickers() {
      $('#datetimepickerfinishby').datetimepicker('destroy');
      $('#datetimepickerendsignup').datetimepicker('destroy');
      $('#datetimepickerendcommitment').datetimepicker('destroy');
      $('#datetimepickerendvote').datetimepicker('destroy');
    }
    // Allow the Election Authority to finish the registration phase...
    function finishRegistration() {
      if (!adminAddressChosen) {
        alert("Please unlock your Ethereum address");
        return;
      }

      if (state != 1) {
        alert("Please wait until Registration Phase");
        return;
      }

      if (anonymousvoting.methods.totalregistered() < 3) {
        alert("Election cannot begin until there is 3 or more registered voters");
        return;
      }

      var time = new Date();
      var finishReg = anonymousvoting.methods.votersFinishSignupPhase() * 1000;

      if (time.getTime() < finishReg) {
        alert("Please wait until " + clockformat(new Date(finishReg)) + " before finishing registration");
        return;
      }

      await web3.eth.personal.unlockAccount(addr, password);

      res = anonymousvoting.methods.finishRegistrationPhase.sendTransaction({ from: accountList[accountindex], gas: 4200000 });
      document.getElementById("finishRegistration").innerHTML = "Waiting for Ethereum to confirm that Registration has finished";

      txlist("Finish Registration Phase: " + res);
    }

    // Tell Ethereum to compute Tally
    function tally() {

      // Ethereum Account needs to be unlocked.
      if (!adminAddressChosen) {
        alert("Please unlock your Ethereum address");
        return;
      }

      // Make sure we are in the correct phase.
      if (state != 3) {
        alert("Please wait until VOTE Phase");
        return;
      }
      var reg = anonymousvoting.methods.totalregistered();
      var voted = anonymousvoting.methods.totalvoted();

      // Make sure everyone has voted!
      if (!reg.equals(voted)) {
        alert("Please wait for everyone to vote");
        return;
      }

      //TODO: Check that all votes have been cast..
      // Can do this by checking the public 'votecast' mapping...
      await web3.eth.personal.unlockAccount(accountList[accountindex], password);
      var res = anonymousvoting.methods.computeTally.sendTransaction({ from: accountList[accountindex], gas: 4200000 });
      document.getElementById("tallybutton").innerHTML = "Waiting for Ethereum to confirm tally";
      txlist("Compute Tally: " + res);
    }

    function reset() {
      await web3.eth.personal.unlockAccount(accountList[accountindex], password);
      var res = anonymousvoting.methods.reset.sendTransaction({ from: accountList[accountindex], gas: 4200000 });
      txlist("Reset: " + res);
    }

    // Update question set for vote.
    async function whatIsQuestion() {

      if (await anonymousvoting.methods.state().call() > 0) {
        var q = await anonymousvoting.methods.question().call();
        document.getElementById('title').innerHTML = q;
      }
    }

    // Keep a list of transaction hashes on the website. Might be useful...
    function txlist(extra) {
      document.getElementById('txlist').innerHTML = document.getElementById('txlist').innerHTML + "<br>" + extra;
    }

    // STEP 1: User must find an Ethereum account that is recognised as the owner of the contract
    // and then the user MUST log in with that account!!
    var openedLogIn = false;
    var signedIn = false;

    async function openLogin() {
      accountList = await web3.eth.getAccounts();


      if (!openedLogIn) {
        openedLogIn = true;
        document.getElementById('login').removeAttribute("hidden");
        var selectbox = "<p>Address: <select id='addrs'>";

        var foundOwner = false;

        let ownerAddr = await anonymousvoting.methods.owner().call();
        // Let user select one of their Ethereum addresses
        for (var i = 0; i < accountList.length; i++) {

          if (ownerAddr == accountList[i]) {
            foundOwner = true;
            selectbox = selectbox + '<option value="' + i + '">' + accountList[i] + '</option>';
          }
        }

        selectbox = selectbox + "</select></p>";
        selectbox = selectbox + "<p>Password: <input type='password' id='passwordf' value='' name='fname'> <button onclick='unlock()' class='btn btn-primary'>Unlock</button> </p>";

        if (foundOwner) {
          document.getElementById('dropdown').innerHTML = selectbox;
        } else {
          document.getElementById('dropdown').innerHTML = "You do not have an Ethereum account that is the Election Authority for this vote";
        }
      }
    }

    async function unlock(callback) {
      var _addr = $('#addrs').find(":selected").text();
      var _password = document.getElementById('passwordf').value;

      let unlocked = await await web3.eth.personal.unlockAccount(_addr, _password)
      if (unlocked) {
        adminAddressChosen = true;
        addr = _addr;
        password = _password;
        accountindex = $("#addrs").val();
        signedIn = true;
        document.getElementById('login').setAttribute("hidden", true);
        currentState();
      }
    }

    // STEP 2: Admin must be able to set a list of eligible voters
    var eligibletextboxCreated = false;
    async function createEligibleTextBox() {

      if (!eligibletextboxCreated) {
        eligibletextboxCreated = true;
        document.getElementById('title').innerHTML = "List of Eligible Voters";
        document.getElementById('question').setAttribute("hidden", true);
        document.getElementById('eligible').removeAttribute("hidden");

        // LAZY: Pre-fill the text box with my addresses in blockchain
        document.getElementById('addresses').value = accountList.slice(1, -1).join(",");
      }

      // compare eligible to all available accounts, minus charity
      let numEligible = accountList.length - 2;
      var res = (await anonymousvoting.methods.totaleligible().call()) == numEligible;
      var isHidden = document.getElementById('eligible').hasAttribute('hidden');

      if (!res && !isHidden) {
        document.getElementById('section_desc').innerHTML = "There is currently <span id='totaleligible'>0</span> eligible voters. <br> Would you like to add more?";
        document.getElementById('totaleligible').innerHTML = await anonymousvoting.methods.totaleligible().call() + "/" + numEligible;
      } else if (!isHidden) {
        document.getElementById('section_desc').innerHTML = "There is currently <span id='totaleligible'>0</span> eligible voters. <br> You cannot add any more voters.";
        document.getElementById('totaleligible').innerHTML = await anonymousvoting.methods.totaleligible().call() + "/" + numEligible;
        document.getElementById('eligible_area').setAttribute("hidden", true);
      }

    }

    async function finishEligible() {
      if (await anonymousvoting.methods.totaleligible().call >= 3) {
        setInitialTimes();
        document.getElementById('title').innerHTML = "The Election Time Table";
        document.getElementById('section_desc').innerHTML = "";
        document.getElementById('eligible').setAttribute("hidden", true);
        document.getElementById('listoftimers').removeAttribute("hidden");
      } else {
        alert("A minimum number of 3 eligible voters is required before continuing.");
      }
    }

    var finishSettingTimes = false;

    function finishSetTimes() {
      document.getElementById('title').innerHTML = "Election Configuration";
      document.getElementById('section_desc').innerHTML = "";
      document.getElementById('listoftimers').setAttribute("hidden", true);
      document.getElementById('registrationSetQuestion').removeAttribute("hidden");
    }

    // STEP 3: Admin must finish the registration phase
    var finishRegistrationCreated = false;
    function createFinishRegistration() {

      if (!finishRegistrationCreated) {
        finishRegistrationCreated = true;
        //  document.getElementById('title').innerHTML = "Voter Registration";
        document.getElementById('eligible').setAttribute("hidden", true);
        document.getElementById('registrationSetQuestion').setAttribute("hidden", true);
        document.getElementById('finishRegistration').removeAttribute("hidden");
        document.getElementById('question').removeAttribute("hidden");

        // Update the state, and finish time.
        var date = new Date();
        date.setTime(anonymousvoting.methods.endSignupPhase() * 1000);
      }

      // Make sure it exists... We might be in the 'Please wait on Ethereum' part.
      if (document.getElementById('totalregistered') != null) {
        document.getElementById('totalregistered').innerHTML = "" + anonymousvoting.methods.totalregistered() + "/" + anonymousvoting.methods.totaleligible() + " voters have registered their ballot.";

        // Statistics on number of registered voters, and when authority can transition to the next phase
        var finishby = document.getElementById('finishby');
        if (finishby != null) {
          var date = new Date();
          date.setTime(anonymousvoting.methods.votersFinishSignupPhase() * 1000);
          document.getElementById('finishby').innerHTML = "You can finish registration after " + clockformat(date);
        }
      }

    }

    var commitCreate = false;
    function createCommit() {

      if (!commitCreate) {
        commitCreate = true;
        document.getElementById('commit').removeAttribute("hidden");
        document.getElementById('finishRegistration').setAttribute("hidden", true);
        document.getElementById('section_desc').innerHTML = "Waiting for voters to submit a commitment, but not reveal their encrypted vote to Etheruem. ";
      }

      document.getElementById('committimer').innerHTML = "Refunds are issued after " + clockformat(new Date(anonymousvoting.methods.endCommitmentPhase() * 1000)) + " if all voters do not commit to their vote.";
      // Keep track of how many voters have been set as eligible.
      document.getElementById('totalcommit').innerHTML = anonymousvoting.methods.totalcommitted() + "/" + anonymousvoting.methods.totalregistered() + " voters have sealed their vote.";

    }

    var voteCreate = false;
    function createVote() {

      if (!voteCreate) {
        voteCreate = true;
        document.getElementById('commit').setAttribute("hidden", true);
        document.getElementById('finishRegistration').setAttribute("hidden", true);
        document.getElementById('votephase').removeAttribute("hidden");
        document.getElementById('section_desc').innerHTML = "";
        controlTransition("#pb_cast");
      }

      document.getElementById('votetimer').innerHTML = "Refunds are issued after " + clockformat(new Date(anonymousvoting.methods.endVotingPhase() * 1000)) + " if all voters do not cast their vote.";
      document.getElementById('totalvoters').innerHTML = anonymousvoting.methods.totalvoted() + "/" + anonymousvoting.methods.totalregistered() + " voters have cast their vote.";
    }

    var tallyCreate = false;
    function createTally() {

      if (!tallyCreate) {
        tallyCreate = true;

        document.getElementById('tallydiv').removeAttribute("hidden");

        // var res1 = anonymousvoting.methods.totalregistered().eq(anonymousvoting.methods.totalvoted());
        // var res2 = !anonymousvoting.methods.totalregistered().eq(new BigNumber("0"));
        // alert(res1 + " " + res2);

        if ((anonymousvoting.methods.totalregistered().eq(anonymousvoting.methods.totalvoted())) && !anonymousvoting.methods.totalregistered().eq(new BigNumber("0"))) {
          var yes = anonymousvoting.methods.finaltally(0);
          var total = anonymousvoting.methods.finaltally(1);
          var no = total - yes;
          document.getElementById("section_desc").innerHTML = "Yes = " + yes + " and No = " + no + "<hr>";
        } else {
          document.getElementById("section_desc").innerHTML = "Voting has been cancelled.";
        }

        document.getElementById("depositrefunded").innerHTML = anonymousvoting.methods.totalrefunded() + "/" + anonymousvoting.methods.totaltorefund() + " voters have received their refund.";
        document.getElementById("newvote").innerHTML = "A new vote can begin after " + clockformat(new Date(anonymousvoting.methods.endRefundPhase() * 1000));
        document.getElementById('votephase').setAttribute("hidden", true);
        document.getElementById('finishRegistration').setAttribute("hidden", true);
        document.getElementById('commit').setAttribute("hidden", true);

        controlTransition("#pb_tally");
      }
    }

    function clockformat(date) {

      if (date.getMinutes() < 10) {
        mins = "0" + date.getMinutes();
      } else {
        mins = date.getMinutes();
      }

      var toString = date.getHours() + ":" + mins + ", "

      toString = toString + (date.getMonth() + 1) + "/" + date.getDate() + "/" + date.getFullYear();

      return toString;
    }

    var alldone = false;

    // Responsible for updating the website's text depending on the election's current phase. (i.e. if we are in VOTE, no point enabling compute button).
    async function currentState() {

      openLogin();

      // Make sure user has unlocked an Ethereum account...
      if (!signedIn) {
        return;
      }

      checkDeadlines();

      //if election is done
      if (alldone) {

        // Check if he has been refunded
        if (await anonymousvoting.methods.refunds(accountList[accountindex]) > 0) {
          document.getElementById("refund-valid").removeAttribute("hidden");
        } else {
          document.getElementById("refund-valid").setAttribute("hidden", true);
        }

        // Just inform election authority that people are still being refunded.
        document.getElementById("depositrefunded").innerHTML = await anonymousvoting.methods.totalrefunded().call() + "/" + await anonymousvoting.methods.totaltorefund().call() + " voters have received their refund."
        return;
      }

      state = await anonymousvoting.methods.state().call();
      console.log("STATE IS: " + state);
      whatIsQuestion();

      if (state == 0) { // SETUP
        console.log("SETUP STATE")
        createEligibleTextBox();
        controlTransition("#pb_setup")
      } else if (state == 1) { // SIGNUP
        console.log("SIGNUP STATE")
        createFinishRegistration();
        controlTransition("#pb_register")
        // Ensure pickers are destroyed
        destroyPickers();
      } else if (state == 2) { // COMMITMENT
        console.log("COMMITMENT STATE")
        createCommit();
        controlTransition("#pb_commit")
        // Ensure pickers are destroyed
        destroyPickers();
      } else if (state == 3) { // VOTE
        console.log("VOTE STATE")
        createVote();
        controlTransition("#pb_cast")
        // Ensure pickers are destroyed
        destroyPickers();
      } else if (state == 4) { // TALLY
        console.log("TALLY STATE")
        createTally();
        controlTransition("#pb_tally")
        //Keep track of the number of voters who have received their refund.
        alldone = true;
        // Ensure pickers are destroyed
        destroyPickers();
      } else {
        console.log("UNDOCUMENTED STATE")
        document.getElementById('state').innerHTML = "Undocumented Phase...";
      }
    }
    setInterval(currentState, 10000);
    currentState();

    var current_fs = "";

    function claimrefund() {

      await web3.eth.personal.unlockAccount(addr, password);
      var res = anonymousvoting.methods.withdrawRefund.call({ from: accountList[accountindex], gas: 4200000 });

      if (res) {
        anonymousvoting.methods.withdrawRefund.sendTransaction({ from: accountList[accountindex], gas: 4200000 });
        document.getElementById('claimrefundbutton').setAttribute("hidden", true);
        document.getElementById("waitingforrefund").removeAttribute("hidden");
      }
      // alert("test");
      return false;
    }


    async function checkDeadlines() {

      var state = await anonymousvoting.methods.state().call();
      var currentTime = new Date().getTime();
      var time = 9999999999999; // High value to always be greater than a unix timestamp

      // Find the relevant time...
      switch (state.toString("10")) {
        case "1":
          time = await anonymousvoting.methods.endSignupPhase().call() * 1000;
          break;
        case "2":
          time = await anonymousvoting.methods.endCommitmentPhase().call() * 1000;
          break;
        case "3":
          time = await anonymousvoting.methods.endVotingPhase().call() * 1000;
          break;
        default:
          break;
      }

      if (currentTime > time) {
        document.getElementById("cancelelec").removeAttribute("hidden");
      } else {
        document.getElementById("cancelelec").setAttribute("hidden", true);
      }

      // Can the election authority claim any deposits?
      if (await anonymousvoting.methods.lostdeposit() > 0) {
        document.getElementById("unspentdeposits").removeAttribute("hidden");
      } else {
        document.getElementById("unspentdeposits").setAttribute("hidden", true);
      }
    }

    async function controlTransition(nextfs) {

      // Prevent weird loop
      if (current_fs == nextfs) {
        return;
      }

      // Nope.. jump to latest state.
      var state = await anonymousvoting.methods.state().call();
      switch (state.toString("10")) {
        case "0":
          $("#pb_setup").addClass("active");
          break;
        case "1":
          $("#pb_setup").addClass("active");
          $("#pb_register").addClass("active");
          break;
        case "2":
          $("#pb_setup").addClass("active");
          $("#pb_register").addClass("active");
          $("#pb_commit").addClass("active");
          break;
        case "3":
          $("#pb_setup").addClass("active");
          $("#pb_register").addClass("active");
          $("#pb_commit").addClass("active");
          $("#pb_cast").addClass("active");
          break;
        case "4":
          $("#pb_setup").addClass("active");
          $("#pb_register").addClass("active");
          $("#pb_commit").addClass("active");
          $("#pb_cast").addClass("active");
          $("#pb_tally").addClass("active");
          break;
        default:
          break;
      }
    }
  </script>